import { notImplemented } from "../../misc/helpers";

export class GeneXusCommonGeolocation {

  /**
   * Returns the current location for the device
   * @param minAccuracy
   * @param timeout
   * @param includeHeadingAndSpeed
   * @param ignoreErrors
   * @return any
   */
  public static getMyLocation(minAccuracy: number, timeout: number, includeHeadingAndSpeed:boolean, ignoreErrors:boolean): Promise<GeneXusCommonGeolocationInfoData> {
    return new Promise<GeneXusCommonGeolocationInfoData>((resolve, reject) => {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition((position: any) => { 
          let geoPosition = new GeneXusCommonGeolocationInfoData();
          geoPosition.Location = position.coords.latitude.toString() + "," + position.coords.longitude.toString();
          geoPosition.Heading = position.coords.heading;
          geoPosition.Precision = position.coords.accuracy;
          geoPosition.Description = "";
          geoPosition.Speed = position.coords.speed;
          geoPosition.Time = position.timestamp;
          resolve(geoPosition);
        }, 
        (error) => {
          if (ignoreErrors) { 
            let geoPosition = new GeneXusCommonGeolocationInfoData();
            geoPosition.Time = null;
            resolve( geoPosition);
          } else {
            reject( "Could not get location information ("+error.message+")");
          }
        },
        {timeout: timeout * 1000});
      } else {
        if (ignoreErrors) { 
          let geoPosition = new GeneXusCommonGeolocationInfoData();
          geoPosition.Time = null;
          resolve( geoPosition);
        } else {
          reject( "Could not get location information (geolocation service not available)");
        }
      }
    });
  }  

  /**
   * Indicates wether the application has been given permission to use location services
   * @return boolean
   */
  public static authorized(): boolean {
    return this.serviceEnabled();
  }

  /**
   * Indicates wether location services are enable in the device
   * @return boolean
   */
  public static serviceEnabled(): boolean {
    return navigator.geolocation ? true : false;
  }

  /**
   * Starts generating tracking information
   * @param changesInterval
   * @param distance
   * @param action
   * @param actionTimeInterval
   * @param accuracy
   * @return any
   */
  public static startTracking(changesInterval: number, distance: number, action: string, actionTimeInterval: number, accuracy: number): any {
    notImplemented('GeneXusCommonGeolocation.startTracking');
    return null;
  }

  /**
   * Stops the generation of tracking information
   * @return any
   */
  public static endTracking(): any {
    notImplemented('GeneXusCommonGeolocation.endTracking');
    return null;
  }

  /**
   * Returns a collection of location information generated by the tracking methods
   * @param startTime
   * @return any
   */
  public static getLocationHistory(startTime: Date): any {
    notImplemented('GeneXusCommonGeolocation.getLocationHistory');
    return null;
  }

  /**
   * Removes all previous location information generated by the tracking methods
   * @return any
   */
  public static clearLocationHistory(): any {
    notImplemented('GeneXusCommonGeolocation.clearLocationHistory');
    return null;
  }

  /**
   * Returns the latitude of the given location
   * @param location
   * @return number
   */
  public static getLatitude(location: GeneXusCommonGeolocationInfoData ): number {
    if (location.Location.indexOf(",") > -1)
    {
      return parseFloat(location.Location.split(",")[0]);
    }
    return 0;
  }

  /**
   * Returns the longitude of the given location
   * @param location
   * @return number
   */
  public static getLongitude(location: any): number {
    if (location.Location.indexOf(",") > -1)
    {
      return parseFloat(location.Location.split(",")[1]);
    }
    return 0;
  }

  /**
   * Returns the distance between the two locations given (haversine formula)
   * @param fromLocation
   * @param toLocation
   * @return number
   */
  public static  getDistance(fromLocation: any, toLocation: any): number {
    const R = 6371e3; // earthâ€™s radius
    const lat1 = this.getLatitude( fromLocation);
    const lon1 = this.getLongitude( fromLocation);
    const lat2 = this.getLatitude( toLocation);
    const lon2 = this.getLongitude( toLocation); 

    const lat1radians = this.toRadians(lat1);
    const lat2radians = this.toRadians(lat2);
 
    const latRadians = this.toRadians(lat2-lat1);
    const lonRadians = this.toRadians(lon2-lon1);
 
    const a = Math.sin(latRadians/2) * Math.sin(latRadians/2) +
         Math.cos(lat1radians) * Math.cos(lat2radians) *
         Math.sin(lonRadians/2) * Math.sin(lonRadians/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
 
    return Math.round(R * c);
  }
 
  /**
   * Returns a collection of addresses for the given location
   * @param location
   * @return any
   */
  public static getAddress(location: any): any {
    notImplemented('GeneXusCommonGeolocation.getAddress');
    return null;
  }

  /**
   * Returns a collection of locations for the given address
   * @param address
   * @return any
   */
  public static getGeolocation(address: any): any {
    notImplemented('GeneXusCommonGeolocation.getGeolocation');
    return null;
  }

  /**
   * @param proximityAlerts
   * @return boolean
   */
  public static setProximityAlerts(proximityAlerts: any): boolean {
    notImplemented('GeneXusCommonGeolocation.setProximityAlerts');
    return false;
  }

  /**
   * @return any
   */
  public static getProximityAlerts(): any {
    notImplemented('GeneXusCommonGeolocation.getProximityAlerts');
    return null;
  }

  /**
   * @return any
   */
  public static getCurrentProximityAlert(): any {
    notImplemented('GeneXusCommonGeolocation.getCurrentProximityAlert');
    return null;
  }

  /**
   * @return any
   */
  public static clearProximityAlerts(): any {
    notImplemented('GeneXusCommonGeolocation.clearProximityAlerts');
    return null;
  }

  /**
   * @param geoLocationPickerParameters
   * @return any
   */
  public static pickLocation(geoLocationPickerParameters: any): any {
    notImplemented('GeneXusCommonGeolocation.pickLocation');
    return null;
  }

  public static toRadians( val: number): number {
    const PI = 3.1415926535;
    return val / 180.0 * PI;
  }

}

export class GeneXusCommonGeolocationInfoData {
  Location: string;
  Description: string;
  Time: Date;
  Precision: number;
  Heading: number;
  Speed: number;

  constructor() {
    this.Location = "";
    this.Description = "";
    this.Time = new Date();
    this.Precision = 0;
    this.Heading = 0;
    this.Speed = 0;
  }
}